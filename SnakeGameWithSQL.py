{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "617a3933-db3c-445c-bb57-7ffbfd6919fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pygame\n",
    "import sys\n",
    "import random\n",
    "import pyodbc\n",
    "    \n",
    "# Initialize pygame\n",
    "pygame.init()\n",
    "\n",
    "# Constants\n",
    "WIDTH, HEIGHT = 640, 480\n",
    "BLOCK_SIZE = 20\n",
    "INPUT_BOX_WIDTH, INPUT_BOX_HEIGHT = 300, 40\n",
    "\n",
    "# Colors\n",
    "WHITE = (255, 255, 255)\n",
    "JAM = (103, 3, 47)\n",
    "RED = (255, 0, 0)\n",
    "GREEN = (0, 128, 0)\n",
    "PURPLE = (128, 0, 128)\n",
    "\n",
    "# Fonts\n",
    "font = pygame.font.SysFont(None, 36)\n",
    "button_font = pygame.font.SysFont(None, 24)\n",
    "\n",
    "# Screen and Clock\n",
    "screen = pygame.display.set_mode((WIDTH, HEIGHT))\n",
    "pygame.display.set_caption('Snake Game by PKKY')\n",
    "clock = pygame.time.Clock()\n",
    "\n",
    "def connect_to_db():\n",
    "    conn = pyodbc.connect('DRIVER={ODBC Driver 17 for SQL Server};'\n",
    "                              'SERVER=DESKTOP-4948HO8;'  \n",
    "                              'DATABASE=SnakeGame;'\n",
    "                              'UID=Pawel2;'\n",
    "                              'PWD=1234;')\n",
    "    return conn\n",
    "\n",
    "def insert_score(nickname, score):\n",
    "    try:\n",
    "        connection = connect_to_db()\n",
    "        cursor = connection.cursor()\n",
    "\n",
    "        # Check if the nickname already exists in the table\n",
    "        select_query = \"SELECT score FROM scores WHERE nickname = ?\"\n",
    "        cursor.execute(select_query, (nickname,))\n",
    "        result = cursor.fetchone()\n",
    "        \n",
    "        if result:\n",
    "            # If nickname exists and new score is better, update it\n",
    "            if score > result[0]:\n",
    "                update_query = \"UPDATE scores SET score = ? WHERE nickname = ?\"\n",
    "                cursor.execute(update_query, (score, nickname))\n",
    "        else:\n",
    "            # If nickname doesn't exist, insert a new record\n",
    "            insert_query = \"INSERT INTO scores (nickname, score) VALUES (?, ?)\"\n",
    "            cursor.execute(insert_query, (nickname, score))\n",
    "        \n",
    "        connection.commit()\n",
    "\n",
    "    except pyodbc.Error as error:\n",
    "        print(\"Failed to insert/update record into table: {}\".format(error))\n",
    "    finally:\n",
    "        cursor.close()\n",
    "        connection.close()\n",
    "\n",
    "def get_scores():\n",
    "    conn = connect_to_db()\n",
    "    cursor = conn.cursor()\n",
    "\n",
    "    cursor.execute(\"SELECT nickname, score FROM scores ORDER BY score DESC\")\n",
    "    rows = cursor.fetchall()\n",
    "\n",
    "    conn.close()\n",
    "\n",
    "    return rows\n",
    "# Score dictionary\n",
    "scores = {}\n",
    "\n",
    "class Snake:\n",
    "    def __init__(self):\n",
    "        self.elements = [[int(WIDTH / 2), int(HEIGHT / 2)]]\n",
    "        self.directions = ['UP']\n",
    "        self.score = 0\n",
    "\n",
    "    def draw(self):\n",
    "        for element in self.elements:\n",
    "            pygame.draw.rect(screen, WHITE, (element[0], element[1], BLOCK_SIZE, BLOCK_SIZE))\n",
    "\n",
    "    def move(self):\n",
    "        cur = self.elements[0].copy()\n",
    "        direction = self.directions[0]\n",
    "\n",
    "        if direction == 'UP':\n",
    "            cur[1] -= BLOCK_SIZE\n",
    "        if direction == 'DOWN':\n",
    "            cur[1] += BLOCK_SIZE\n",
    "        if direction == 'LEFT':\n",
    "            cur[0] -= BLOCK_SIZE\n",
    "        if direction == 'RIGHT':\n",
    "            cur[0] += BLOCK_SIZE\n",
    "\n",
    "        self.elements = [cur] + self.elements[:-1]\n",
    "\n",
    "    def add_block(self):\n",
    "        self.elements.append(self.elements[-1].copy())\n",
    "        self.score += 1\n",
    "\n",
    "def input_name():\n",
    "    input_box = pygame.Rect(WIDTH // 2 - INPUT_BOX_WIDTH // 2, HEIGHT // 2 - INPUT_BOX_HEIGHT // 2, INPUT_BOX_WIDTH, INPUT_BOX_HEIGHT)\n",
    "    color_inactive = pygame.Color('lightskyblue3')\n",
    "    color_active = pygame.Color('dodgerblue2')\n",
    "    color = color_inactive\n",
    "    active = False\n",
    "    text = ''\n",
    "    font = pygame.font.Font(None, 32)\n",
    "    warning_font = pygame.font.Font(None, 24)\n",
    "    clock = pygame.time.Clock()\n",
    "    max_length = 15\n",
    "    empty_input = False  # To check for empty input\n",
    "\n",
    "    while True:\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                sys.exit()\n",
    "            if event.type == pygame.MOUSEBUTTONDOWN:\n",
    "                if input_box.collidepoint(event.pos):\n",
    "                    active = not active\n",
    "                else:\n",
    "                    active = False\n",
    "                color = color_active if active else color_inactive\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if active:\n",
    "                    if event.key == pygame.K_RETURN:\n",
    "                        if not text:  # If the input box is empty\n",
    "                            empty_input = True\n",
    "                        else:\n",
    "                            return text\n",
    "                    elif event.key == pygame.K_BACKSPACE:\n",
    "                        text = text[:-1]\n",
    "                    else:\n",
    "                        if len(text) < max_length:\n",
    "                            text += event.unicode\n",
    "                            empty_input = False\n",
    "                if event.key == pygame.K_ESCAPE:\n",
    "                    return main_menu()\n",
    "\n",
    "        screen.fill(JAM)\n",
    "        \n",
    "        label = font.render(\"Your nick: \", True, WHITE)\n",
    "        screen.blit(label, (WIDTH // 2 - label.get_width() // 2, HEIGHT // 2 - 65))\n",
    "        \n",
    "        txt_surface = font.render(text, True, color)\n",
    "        width = max(INPUT_BOX_WIDTH, txt_surface.get_width()+10)\n",
    "        input_box.w = width\n",
    "        screen.blit(txt_surface, (input_box.x+5, input_box.y+5))\n",
    "        pygame.draw.rect(screen, color, input_box, 2)\n",
    "\n",
    "        # Display warning if the input is empty\n",
    "        if empty_input:\n",
    "            warning_message = warning_font.render(\"The input box can't be empty\", True, RED)\n",
    "            screen.blit(warning_message, (WIDTH // 2 - warning_message.get_width() // 2, input_box.bottom + 10))\n",
    "\n",
    "        pygame.display.flip()\n",
    "        clock.tick(30)\n",
    "\n",
    "def show_scoreboard():\n",
    "    # Fetch scores from the database\n",
    "    fetched_scores = get_scores()\n",
    "\n",
    "    while True:\n",
    "        screen.fill(JAM)\n",
    "        y_offset = 50\n",
    "\n",
    "        title_text = font.render(\"Scoreboard\", True, WHITE)\n",
    "        screen.blit(title_text, (WIDTH // 2 - title_text.get_width() // 2, 10))\n",
    "\n",
    "        y_offset += 20\n",
    "        \n",
    "        # Loop through the scores fetched from the database\n",
    "        for name, score in fetched_scores:\n",
    "            score_text = font.render(f\"{name}: {score}\", True, WHITE)\n",
    "            screen.blit(score_text, (WIDTH // 2 - score_text.get_width() // 2, y_offset))\n",
    "            y_offset += 40\n",
    "\n",
    "        back_button = pygame.Rect(20, 20, 100, 40)\n",
    "        pygame.draw.rect(screen, WHITE, back_button)\n",
    "        back_text = button_font.render(\"Back\", True, JAM)\n",
    "        screen.blit(back_text, (back_button.x + (back_button.width - back_text.get_width()) // 2,\n",
    "                                back_button.y + (back_button.height - back_text.get_height()) // 2))\n",
    "        \n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                sys.exit()\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if event.key == pygame.K_ESCAPE:\n",
    "                    return\n",
    "            if event.type == pygame.MOUSEBUTTONDOWN:\n",
    "                # Check if \"Back\" button is clicked\n",
    "                if back_button.collidepoint(event.pos):\n",
    "                    return\n",
    "\n",
    "        pygame.display.update()\n",
    "        clock.tick(60)\n",
    "\n",
    "class Food:\n",
    "    def __init__(self):\n",
    "        self.position = [random.randint(0, (WIDTH // BLOCK_SIZE - 1)) * BLOCK_SIZE,\n",
    "                         random.randint(0, (HEIGHT // BLOCK_SIZE - 1)) * BLOCK_SIZE]\n",
    "        self.is_food_on_screen = True\n",
    "\n",
    "    def draw(self):\n",
    "        pygame.draw.rect(screen, RED, (self.position[0], self.position[1], BLOCK_SIZE, BLOCK_SIZE))\n",
    "\n",
    "def draw_grid():\n",
    "    for x in range(0, WIDTH, BLOCK_SIZE):\n",
    "        pygame.draw.line(screen, WHITE, (x, 0), (x, HEIGHT))\n",
    "    for y in range(0, HEIGHT, BLOCK_SIZE):\n",
    "        pygame.draw.line(screen, WHITE, (0, y), (WIDTH, y))\n",
    "\n",
    "def check_collision(elements, x, y):\n",
    "    for element in elements:\n",
    "        if element[0] == x and element[1] == y:\n",
    "            return True\n",
    "    return False\n",
    "\n",
    "def game_loop(player_name):\n",
    "    snake = Snake()\n",
    "    food = Food()\n",
    "\n",
    "    direction = 'UP'\n",
    "    change_to = direction\n",
    "\n",
    "    while True:\n",
    "        screen.fill(JAM)\n",
    "\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                sys.exit()\n",
    "\n",
    "            # Whenever a key is pressed down\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if event.key == pygame.K_UP and not direction == 'DOWN':\n",
    "                    change_to = 'UP'\n",
    "                if event.key == pygame.K_DOWN and not direction == 'UP':\n",
    "                    change_to = 'DOWN'\n",
    "                if event.key == pygame.K_LEFT and not direction == 'RIGHT':\n",
    "                    change_to = 'LEFT'\n",
    "                if event.key == pygame.K_RIGHT and not direction == 'LEFT':\n",
    "                    change_to = 'RIGHT'\n",
    "                if event.key == pygame.K_r:\n",
    "                    return True\n",
    "\n",
    "        # Update direction \n",
    "        direction = change_to\n",
    "        \n",
    "        snake.directions.insert(0, direction)\n",
    "\n",
    "        if len(snake.directions) > snake.score + 1:\n",
    "            snake.directions.pop()\n",
    "\n",
    "        if food.is_food_on_screen is False:\n",
    "            food.position = [random.randint(0, (WIDTH // BLOCK_SIZE - 1)) * BLOCK_SIZE,\n",
    "                             random.randint(0, (HEIGHT // BLOCK_SIZE - 1)) * BLOCK_SIZE]\n",
    "            food.is_food_on_screen = True\n",
    "        snake.move()\n",
    "\n",
    "        # Snake collision with itself\n",
    "        if snake.elements[0] in snake.elements[1:]:\n",
    "            while True:\n",
    "                screen.fill(JAM)\n",
    "                lost_message = font.render(f\"You lost, {player_name}: {snake.score}\", True, WHITE)\n",
    "                message_rect = lost_message.get_rect(center=(WIDTH / 2, HEIGHT / 2))\n",
    "                screen.blit(lost_message, message_rect.topleft)\n",
    "        \n",
    "                restart_message = font.render(\"Press R to restart or ESC to return to main menu\", True, WHITE)\n",
    "                restart_rect = restart_message.get_rect(center=(WIDTH / 2, HEIGHT / 2 + 40))\n",
    "                screen.blit(restart_message, restart_rect.topleft)\n",
    "        \n",
    "                pygame.display.flip()\n",
    "        \n",
    "                for event in pygame.event.get():\n",
    "                    if event.type == pygame.QUIT:\n",
    "                        pygame.quit()\n",
    "                        sys.exit()\n",
    "                    if event.type == pygame.KEYDOWN:\n",
    "                        if event.key == pygame.K_r:\n",
    "                            return game_loop(player_name)\n",
    "                        if event.key == pygame.K_ESCAPE:\n",
    "                            return snake.score  # Return score and go back to the main menu\n",
    "\n",
    "        # Food and Snake collision\n",
    "        if check_collision(snake.elements, food.position[0], food.position[1]):\n",
    "            snake.add_block()\n",
    "            food.is_food_on_screen = False\n",
    "\n",
    "        # Wrap snake if it hits the wall\n",
    "        if snake.elements[0][0] < 0:\n",
    "            snake.elements[0][0] = WIDTH - BLOCK_SIZE\n",
    "        if snake.elements[0][0] >= WIDTH:\n",
    "            snake.elements[0][0] = 0\n",
    "        if snake.elements[0][1] < 0:\n",
    "            snake.elements[0][1] = HEIGHT - BLOCK_SIZE\n",
    "        if snake.elements[0][1] >= HEIGHT:\n",
    "            snake.elements[0][1] = 0\n",
    "\n",
    "        snake.draw()\n",
    "        food.draw()\n",
    "        draw_grid()\n",
    "\n",
    "        screen.blit(font.render(f\"Score: {snake.score}\", True, WHITE), (10, 10))\n",
    "\n",
    "        pygame.display.flip()\n",
    "        clock.tick(10)\n",
    "    return False\n",
    "\n",
    "def main_menu():\n",
    "    while True:\n",
    "        screen.fill(JAM)\n",
    "        draw_button(\"Start Game\", WIDTH // 2 - 100, HEIGHT // 2 - 40, 200, 40)\n",
    "        draw_button(\"Scoreboard\", WIDTH // 2 - 100, HEIGHT // 2 + 10, 200, 40)\n",
    "        draw_button(\"Quit\", WIDTH // 2 - 100, HEIGHT // 2 + 60, 200, 40)\n",
    "\n",
    "        mx, my = pygame.mouse.get_pos()\n",
    "\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                sys.exit()\n",
    "\n",
    "            if event.type == pygame.MOUSEBUTTONDOWN:\n",
    "                if WIDTH // 2 - 100 <= mx <= WIDTH // 2 + 100 and HEIGHT // 2 - 40 <= my <= HEIGHT // 2:\n",
    "                    player_name = input_name()\n",
    "                    score = game_loop(player_name)\n",
    "                    if player_name not in scores or score > scores[player_name]:\n",
    "                        scores[player_name] = score\n",
    "                    insert_score(player_name, score)  # Save the scores after updating\n",
    "\n",
    "                if WIDTH // 2 - 100 <= mx <= WIDTH // 2 + 100 and HEIGHT // 2 + 10 <= my <= HEIGHT // 2 + 50:\n",
    "                    show_scoreboard()\n",
    "                if WIDTH // 2 - 100 <= mx <= WIDTH // 2 + 100 and HEIGHT // 2 + 60 <= my <= HEIGHT // 2 + 100:\n",
    "                    pygame.quit()\n",
    "                    sys.exit()\n",
    "\n",
    "        label = font.render(\"SNAKE GAME by PKKY\", True, WHITE)\n",
    "        screen.blit(label, (WIDTH // 2 - label.get_width() // 2, HEIGHT // 2 - 150))\n",
    "        pygame.display.update()\n",
    "        clock.tick(60)\n",
    "\n",
    "def draw_button(message, x, y, w, h):\n",
    "    pygame.draw.rect(screen, WHITE, (x, y, w, h))\n",
    "    pygame.draw.rect(screen, JAM, (x + 2, y + 2, w - 4, h - 4))\n",
    "    text = button_font.render(message, True, WHITE)\n",
    "    screen.blit(text, (x + (w - text.get_width()) // 2, y + (h - text.get_height()) // 2))\n",
    "\n",
    "main_menu()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3b655730-15dd-43f2-9635-6141c310a602",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
